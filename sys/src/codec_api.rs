/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const FRAME_NUM_PARAM_SET: ::std::os::raw::c_int = -1;
pub const FRAME_NUM_IDR: ::std::os::raw::c_uint = 0;
pub const DEBLOCKING_OFFSET: ::std::os::raw::c_uint = 6;
pub const DEBLOCKING_OFFSET_MINUS: ::std::os::raw::c_int = -6;
pub const MAX_TEMPORAL_LAYER_NUM: ::std::os::raw::c_uint = 4;
pub const MAX_SPATIAL_LAYER_NUM: ::std::os::raw::c_uint = 4;
pub const MAX_QUALITY_LAYER_NUM: ::std::os::raw::c_uint = 4;
pub const MAX_LAYER_NUM_OF_FRAME: ::std::os::raw::c_uint = 128;
pub const MAX_NAL_UNITS_IN_LAYER: ::std::os::raw::c_uint = 128;
pub const MAX_RTP_PAYLOAD_LEN: ::std::os::raw::c_uint = 1000;
pub const AVERAGE_RTP_PAYLOAD_LEN: ::std::os::raw::c_uint = 800;
pub const SAVED_NALUNIT_NUM_TMP: ::std::os::raw::c_uint = 21;
pub const MAX_SLICES_NUM_TMP: ::std::os::raw::c_uint = 35;
pub const AUTO_REF_PIC_COUNT: ::std::os::raw::c_int = -1;
pub const UNSPECIFIED_BIT_RATE: ::std::os::raw::c_uint = 0;
pub const videoFormatRGB: _bindgen_ty_1 = _bindgen_ty_1::videoFormatRGB;
pub const videoFormatRGBA: _bindgen_ty_1 = _bindgen_ty_1::videoFormatRGBA;
pub const videoFormatRGB555: _bindgen_ty_1 = _bindgen_ty_1::videoFormatRGB555;
pub const videoFormatRGB565: _bindgen_ty_1 = _bindgen_ty_1::videoFormatRGB565;
pub const videoFormatBGR: _bindgen_ty_1 = _bindgen_ty_1::videoFormatBGR;
pub const videoFormatBGRA: _bindgen_ty_1 = _bindgen_ty_1::videoFormatBGRA;
pub const videoFormatABGR: _bindgen_ty_1 = _bindgen_ty_1::videoFormatABGR;
pub const videoFormatARGB: _bindgen_ty_1 = _bindgen_ty_1::videoFormatARGB;
pub const videoFormatYUY2: _bindgen_ty_1 = _bindgen_ty_1::videoFormatYUY2;
pub const videoFormatYVYU: _bindgen_ty_1 = _bindgen_ty_1::videoFormatYVYU;
pub const videoFormatUYVY: _bindgen_ty_1 = _bindgen_ty_1::videoFormatUYVY;
pub const videoFormatI420: _bindgen_ty_1 = _bindgen_ty_1::videoFormatI420;
pub const videoFormatYV12: _bindgen_ty_1 = _bindgen_ty_1::videoFormatYV12;
pub const videoFormatInternal: _bindgen_ty_1 =
    _bindgen_ty_1::videoFormatInternal;
pub const videoFormatNV12: _bindgen_ty_1 = _bindgen_ty_1::videoFormatNV12;
pub const videoFormatVFlip: _bindgen_ty_1 = _bindgen_ty_1::videoFormatVFlip;
#[repr(u32)]
/**
* @brief Enumerate the type of video format
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    videoFormatRGB = 1,
    videoFormatRGBA = 2,
    videoFormatRGB555 = 3,
    videoFormatRGB565 = 4,
    videoFormatBGR = 5,
    videoFormatBGRA = 6,
    videoFormatABGR = 7,
    videoFormatARGB = 8,
    videoFormatYUY2 = 20,
    videoFormatYVYU = 21,
    videoFormatUYVY = 22,
    videoFormatI420 = 23,
    videoFormatYV12 = 24,
    videoFormatInternal = 25,
    videoFormatNV12 = 26,
    videoFormatVFlip = 2147483648,
}
pub use self::_bindgen_ty_1 as EVideoFormatType;
pub const videoFrameTypeInvalid: _bindgen_ty_2 =
    _bindgen_ty_2::videoFrameTypeInvalid;
pub const videoFrameTypeIDR: _bindgen_ty_2 = _bindgen_ty_2::videoFrameTypeIDR;
pub const videoFrameTypeI: _bindgen_ty_2 = _bindgen_ty_2::videoFrameTypeI;
pub const videoFrameTypeP: _bindgen_ty_2 = _bindgen_ty_2::videoFrameTypeP;
pub const videoFrameTypeSkip: _bindgen_ty_2 =
    _bindgen_ty_2::videoFrameTypeSkip;
pub const videoFrameTypeIPMixed: _bindgen_ty_2 =
    _bindgen_ty_2::videoFrameTypeIPMixed;
#[repr(u32)]
/**
* @brief Enumerate  video frame type
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    videoFrameTypeInvalid = 0,
    videoFrameTypeIDR = 1,
    videoFrameTypeI = 2,
    videoFrameTypeP = 3,
    videoFrameTypeSkip = 4,
    videoFrameTypeIPMixed = 5,
}
pub use self::_bindgen_ty_2 as EVideoFrameType;
pub const cmResultSuccess: _bindgen_ty_3 = _bindgen_ty_3::cmResultSuccess;
pub const cmInitParaError: _bindgen_ty_3 = _bindgen_ty_3::cmInitParaError;
pub const cmUnknownReason: _bindgen_ty_3 = _bindgen_ty_3::cmUnknownReason;
pub const cmMallocMemeError: _bindgen_ty_3 = _bindgen_ty_3::cmMallocMemeError;
pub const cmInitExpected: _bindgen_ty_3 = _bindgen_ty_3::cmInitExpected;
pub const cmUnsupportedData: _bindgen_ty_3 = _bindgen_ty_3::cmUnsupportedData;
#[repr(u32)]
/**
* @brief Enumerate  return type
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    cmResultSuccess = 0,
    cmInitParaError = 1,
    cmUnknownReason = 2,
    cmMallocMemeError = 3,
    cmInitExpected = 4,
    cmUnsupportedData = 5,
}
pub use self::_bindgen_ty_3 as CM_RETURN;
#[repr(u32)]
/**
* @brief Enumulate the nal unit type
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ENalUnitType {
    NAL_UNKNOWN = 0,
    NAL_SLICE = 1,
    NAL_SLICE_DPA = 2,
    NAL_SLICE_DPB = 3,
    NAL_SLICE_DPC = 4,
    NAL_SLICE_IDR = 5,
    NAL_SEI = 6,
    NAL_SPS = 7,
    NAL_PPS = 8,
}
#[repr(u32)]
/**
* @brief NRI: eNalRefIdc
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ENalPriority {
    NAL_PRIORITY_DISPOSABLE = 0,
    NAL_PRIORITY_LOW = 1,
    NAL_PRIORITY_HIGH = 2,
    NAL_PRIORITY_HIGHEST = 3,
}
pub const DEBLOCKING_IDC_0: _bindgen_ty_4 = _bindgen_ty_4::DEBLOCKING_IDC_0;
pub const DEBLOCKING_IDC_1: _bindgen_ty_4 = _bindgen_ty_4::DEBLOCKING_IDC_1;
pub const DEBLOCKING_IDC_2: _bindgen_ty_4 = _bindgen_ty_4::DEBLOCKING_IDC_2;
#[repr(u32)]
/**
 * @brief eDeblockingIdc
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    DEBLOCKING_IDC_0 = 0,
    DEBLOCKING_IDC_1 = 1,
    DEBLOCKING_IDC_2 = 2,
}
pub type ERR_TOOL = ::std::os::raw::c_ushort;
pub const ET_NONE: _bindgen_ty_5 = _bindgen_ty_5::ET_NONE;
pub const ET_IP_SCALE: _bindgen_ty_5 = _bindgen_ty_5::ET_IP_SCALE;
pub const ET_FMO: _bindgen_ty_5 = _bindgen_ty_5::ET_FMO;
pub const ET_IR_R1: _bindgen_ty_5 = _bindgen_ty_5::ET_IR_R1;
pub const ET_IR_R2: _bindgen_ty_5 = _bindgen_ty_5::ET_IR_R2;
pub const ET_IR_R3: _bindgen_ty_5 = _bindgen_ty_5::ET_IR_R3;
pub const ET_FEC_HALF: _bindgen_ty_5 = _bindgen_ty_5::ET_FEC_HALF;
pub const ET_FEC_FULL: _bindgen_ty_5 = _bindgen_ty_5::ET_FEC_FULL;
pub const ET_RFS: _bindgen_ty_5 = _bindgen_ty_5::ET_RFS;
#[repr(u32)]
/**
 @brief to do
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    ET_NONE = 0,
    ET_IP_SCALE = 1,
    ET_FMO = 2,
    ET_IR_R1 = 4,
    ET_IR_R2 = 8,
    ET_IR_R3 = 16,
    ET_FEC_HALF = 32,
    ET_FEC_FULL = 64,
    ET_RFS = 128,
}
/**
* @brief Information of coded Slice(=NAL)(s)
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SliceInformation {
    ///< base buffer of coded slice(s)
    pub pBufferOfSlices: *mut ::std::os::raw::c_uchar,
    ///< number of coded slices
    pub iCodedSliceCount: ::std::os::raw::c_int,
    ///< array of slices length accordingly by number of slice
    pub pLengthOfSlices: *mut ::std::os::raw::c_uint,
    ///< FEC type[0, 50%FEC, 100%FEC]
    pub iFecType: ::std::os::raw::c_int,
    ///< index of slice in frame [FMO: 0,..,uiSliceCount-1; No FMO: 0]
    pub uiSliceIdx: ::std::os::raw::c_uchar,
    ///< count number of slice in frame [FMO: 2-8; No FMO: 1]
    pub uiSliceCount: ::std::os::raw::c_uchar,
    ///< index of frame[-1, .., idr_interval-1]
    pub iFrameIndex: ::std::os::raw::c_char,
    ///< NRI, priority level of slice(NAL)
    pub uiNalRefIdc: ::std::os::raw::c_uchar,
    ///< NAL type
    pub uiNalType: ::std::os::raw::c_uchar,
    ///< whether final NAL is involved in buffer of coded slices, flag used in Pause feature in T27
    pub uiContainingFinalNal: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SliceInformation() {
    assert_eq!(::std::mem::size_of::<SliceInformation>() , 40usize);
    assert_eq!(::std::mem::align_of::<SliceInformation>() , 8usize);
}
impl Clone for SliceInformation {
    fn clone(&self) -> Self { *self }
}
pub type SliceInfo = SliceInformation;
pub type PSliceInfo = *mut SliceInformation;
/**
* @brief thresholds of the initial, maximal and minimal rate
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_6 {
    ///< frame width
    pub iWidth: ::std::os::raw::c_int,
    ///< frame height
    pub iHeight: ::std::os::raw::c_int,
    ///< threshold of initial rate
    pub iThresholdOfInitRate: ::std::os::raw::c_int,
    ///< threshold of maximal rate
    pub iThresholdOfMaxRate: ::std::os::raw::c_int,
    ///< threshold of minimal rate
    pub iThresholdOfMinRate: ::std::os::raw::c_int,
    ///< min frame rate min
    pub iMinThresholdFrameRate: ::std::os::raw::c_int,
    ///< skip to frame rate min
    pub iSkipFrameRate: ::std::os::raw::c_int,
    ///< how many frames to skip
    pub iSkipFrameStep: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_6>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_6>() , 4usize);
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
pub type SRateThresholds = _bindgen_ty_6;
pub type PRateThresholds = *mut _bindgen_ty_6;
/**
* @brief  Structure for decoder memery
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagSysMemBuffer {
    ///< width of decoded pic for display
    pub iWidth: ::std::os::raw::c_int,
    ///< height of decoded pic for display
    pub iHeight: ::std::os::raw::c_int,
    ///< type is "EVideoFormatType"
    pub iFormat: ::std::os::raw::c_int,
    ///< stride of 2 component
    pub iStride: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_TagSysMemBuffer() {
    assert_eq!(::std::mem::size_of::<TagSysMemBuffer>() , 20usize);
    assert_eq!(::std::mem::align_of::<TagSysMemBuffer>() , 4usize);
}
impl Clone for TagSysMemBuffer {
    fn clone(&self) -> Self { *self }
}
pub type SSysMEMBuffer = TagSysMemBuffer;
/**
* @brief  Buffer info
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagBufferInfo {
    ///< 0: one frame data is not ready; 1: one frame data is ready
    pub iBufferStatus: ::std::os::raw::c_int,
    ///< input BS timestamp
    pub uiInBsTimeStamp: ::std::os::raw::c_ulonglong,
    ///< output YUV timestamp, when bufferstatus is 1
    pub uiOutYuvTimeStamp: ::std::os::raw::c_ulonglong,
    ///<  output buffer info
    pub UsrData: TagBufferInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagBufferInfo__bindgen_ty_1 {
    ///<  memory info for one picture
    pub sSystemBuffer: __BindgenUnionField<SSysMEMBuffer>,
    pub bindgen_union_field: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_TagBufferInfo__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TagBufferInfo__bindgen_ty_1>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<TagBufferInfo__bindgen_ty_1>() ,
               4usize);
}
impl Clone for TagBufferInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TagBufferInfo() {
    assert_eq!(::std::mem::size_of::<TagBufferInfo>() , 48usize);
    assert_eq!(::std::mem::align_of::<TagBufferInfo>() , 8usize);
}
impl Clone for TagBufferInfo {
    fn clone(&self) -> Self { *self }
}
pub type SBufferInfo = TagBufferInfo;
extern "C" {
    #[link_name = "kiKeyNumMultiple"]
    pub static mut kiKeyNumMultiple: [::std::os::raw::c_char; 6usize];
}
/**
 * @brief Struct of OpenH264 version
 */
///
/// E.g. SDK version is 1.2.0.0, major version number is 1, minor version number is 2, and revision number is 0.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _tagVersion {
    ///< The major version number
    pub uMajor: ::std::os::raw::c_uint,
    ///< The minor version number
    pub uMinor: ::std::os::raw::c_uint,
    ///< The revision number
    pub uRevision: ::std::os::raw::c_uint,
    ///< The reserved number, it should be 0.
    pub uReserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__tagVersion() {
    assert_eq!(::std::mem::size_of::<_tagVersion>() , 16usize);
    assert_eq!(::std::mem::align_of::<_tagVersion>() , 4usize);
}
impl Clone for _tagVersion {
    fn clone(&self) -> Self { *self }
}
pub type OpenH264Version = _tagVersion;
pub const dsErrorFree: _bindgen_ty_7 = _bindgen_ty_7::dsErrorFree;
pub const dsFramePending: _bindgen_ty_7 = _bindgen_ty_7::dsFramePending;
pub const dsRefLost: _bindgen_ty_7 = _bindgen_ty_7::dsRefLost;
pub const dsBitstreamError: _bindgen_ty_7 = _bindgen_ty_7::dsBitstreamError;
pub const dsDepLayerLost: _bindgen_ty_7 = _bindgen_ty_7::dsDepLayerLost;
pub const dsNoParamSets: _bindgen_ty_7 = _bindgen_ty_7::dsNoParamSets;
pub const dsDataErrorConcealed: _bindgen_ty_7 =
    _bindgen_ty_7::dsDataErrorConcealed;
pub const dsInvalidArgument: _bindgen_ty_7 = _bindgen_ty_7::dsInvalidArgument;
pub const dsInitialOptExpected: _bindgen_ty_7 =
    _bindgen_ty_7::dsInitialOptExpected;
pub const dsOutOfMemory: _bindgen_ty_7 = _bindgen_ty_7::dsOutOfMemory;
pub const dsDstBufNeedExpan: _bindgen_ty_7 = _bindgen_ty_7::dsDstBufNeedExpan;
#[repr(u32)]
/**
* @brief Decoding status
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    dsErrorFree = 0,
    dsFramePending = 1,
    dsRefLost = 2,
    dsBitstreamError = 4,
    dsDepLayerLost = 8,
    dsNoParamSets = 16,
    dsDataErrorConcealed = 32,
    dsInvalidArgument = 4096,
    dsInitialOptExpected = 8192,
    dsOutOfMemory = 16384,
    dsDstBufNeedExpan = 32768,
}
pub use self::_bindgen_ty_7 as DECODING_STATE;
pub const ENCODER_OPTION_DATAFORMAT: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_DATAFORMAT;
pub const ENCODER_OPTION_IDR_INTERVAL: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_IDR_INTERVAL;
pub const ENCODER_OPTION_SVC_ENCODE_PARAM_BASE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_SVC_ENCODE_PARAM_BASE;
pub const ENCODER_OPTION_SVC_ENCODE_PARAM_EXT: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_SVC_ENCODE_PARAM_EXT;
pub const ENCODER_OPTION_FRAME_RATE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_FRAME_RATE;
pub const ENCODER_OPTION_BITRATE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_BITRATE;
pub const ENCODER_OPTION_MAX_BITRATE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_MAX_BITRATE;
pub const ENCODER_OPTION_INTER_SPATIAL_PRED: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_INTER_SPATIAL_PRED;
pub const ENCODER_OPTION_RC_MODE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_RC_MODE;
pub const ENCODER_OPTION_RC_FRAME_SKIP: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_RC_FRAME_SKIP;
pub const ENCODER_PADDING_PADDING: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_PADDING_PADDING;
pub const ENCODER_OPTION_PROFILE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_PROFILE;
pub const ENCODER_OPTION_LEVEL: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_LEVEL;
pub const ENCODER_OPTION_NUMBER_REF: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_NUMBER_REF;
pub const ENCODER_OPTION_DELIVERY_STATUS: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_DELIVERY_STATUS;
pub const ENCODER_LTR_RECOVERY_REQUEST: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_LTR_RECOVERY_REQUEST;
pub const ENCODER_LTR_MARKING_FEEDBACK: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_LTR_MARKING_FEEDBACK;
pub const ENCODER_LTR_MARKING_PERIOD: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_LTR_MARKING_PERIOD;
pub const ENCODER_OPTION_LTR: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_LTR;
pub const ENCODER_OPTION_COMPLEXITY: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_COMPLEXITY;
pub const ENCODER_OPTION_ENABLE_SSEI: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_ENABLE_SSEI;
pub const ENCODER_OPTION_ENABLE_PREFIX_NAL_ADDING: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_ENABLE_PREFIX_NAL_ADDING;
pub const ENCODER_OPTION_ENABLE_SPS_PPS_ID_ADDITION: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_ENABLE_SPS_PPS_ID_ADDITION;
pub const ENCODER_OPTION_CURRENT_PATH: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_CURRENT_PATH;
pub const ENCODER_OPTION_DUMP_FILE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_DUMP_FILE;
pub const ENCODER_OPTION_TRACE_LEVEL: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_TRACE_LEVEL;
pub const ENCODER_OPTION_TRACE_CALLBACK: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_TRACE_CALLBACK;
pub const ENCODER_OPTION_TRACE_CALLBACK_CONTEXT: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_TRACE_CALLBACK_CONTEXT;
pub const ENCODER_OPTION_GET_STATISTICS: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_GET_STATISTICS;
pub const ENCODER_OPTION_STATISTICS_LOG_INTERVAL: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_STATISTICS_LOG_INTERVAL;
pub const ENCODER_OPTION_IS_LOSSLESS_LINK: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_IS_LOSSLESS_LINK;
pub const ENCODER_OPTION_BITS_VARY_PERCENTAGE: _bindgen_ty_8 =
    _bindgen_ty_8::ENCODER_OPTION_BITS_VARY_PERCENTAGE;
#[repr(u32)]
/**
* @brief Option types introduced in SVC encoder application
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    ENCODER_OPTION_DATAFORMAT = 0,
    ENCODER_OPTION_IDR_INTERVAL = 1,
    ENCODER_OPTION_SVC_ENCODE_PARAM_BASE = 2,
    ENCODER_OPTION_SVC_ENCODE_PARAM_EXT = 3,
    ENCODER_OPTION_FRAME_RATE = 4,
    ENCODER_OPTION_BITRATE = 5,
    ENCODER_OPTION_MAX_BITRATE = 6,
    ENCODER_OPTION_INTER_SPATIAL_PRED = 7,
    ENCODER_OPTION_RC_MODE = 8,
    ENCODER_OPTION_RC_FRAME_SKIP = 9,
    ENCODER_PADDING_PADDING = 10,
    ENCODER_OPTION_PROFILE = 11,
    ENCODER_OPTION_LEVEL = 12,
    ENCODER_OPTION_NUMBER_REF = 13,
    ENCODER_OPTION_DELIVERY_STATUS = 14,
    ENCODER_LTR_RECOVERY_REQUEST = 15,
    ENCODER_LTR_MARKING_FEEDBACK = 16,
    ENCODER_LTR_MARKING_PERIOD = 17,
    ENCODER_OPTION_LTR = 18,
    ENCODER_OPTION_COMPLEXITY = 19,
    ENCODER_OPTION_ENABLE_SSEI = 20,
    ENCODER_OPTION_ENABLE_PREFIX_NAL_ADDING = 21,
    ENCODER_OPTION_ENABLE_SPS_PPS_ID_ADDITION = 22,
    ENCODER_OPTION_CURRENT_PATH = 23,
    ENCODER_OPTION_DUMP_FILE = 24,
    ENCODER_OPTION_TRACE_LEVEL = 25,
    ENCODER_OPTION_TRACE_CALLBACK = 26,
    ENCODER_OPTION_TRACE_CALLBACK_CONTEXT = 27,
    ENCODER_OPTION_GET_STATISTICS = 28,
    ENCODER_OPTION_STATISTICS_LOG_INTERVAL = 29,
    ENCODER_OPTION_IS_LOSSLESS_LINK = 30,
    ENCODER_OPTION_BITS_VARY_PERCENTAGE = 31,
}
pub use self::_bindgen_ty_8 as ENCODER_OPTION;
pub const DECODER_OPTION_END_OF_STREAM: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_END_OF_STREAM;
pub const DECODER_OPTION_VCL_NAL: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_VCL_NAL;
pub const DECODER_OPTION_TEMPORAL_ID: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_TEMPORAL_ID;
pub const DECODER_OPTION_FRAME_NUM: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_FRAME_NUM;
pub const DECODER_OPTION_IDR_PIC_ID: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_IDR_PIC_ID;
pub const DECODER_OPTION_LTR_MARKING_FLAG: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_LTR_MARKING_FLAG;
pub const DECODER_OPTION_LTR_MARKED_FRAME_NUM: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_LTR_MARKED_FRAME_NUM;
pub const DECODER_OPTION_ERROR_CON_IDC: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_ERROR_CON_IDC;
pub const DECODER_OPTION_TRACE_LEVEL: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_TRACE_LEVEL;
pub const DECODER_OPTION_TRACE_CALLBACK: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_TRACE_CALLBACK;
pub const DECODER_OPTION_TRACE_CALLBACK_CONTEXT: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_TRACE_CALLBACK_CONTEXT;
pub const DECODER_OPTION_GET_STATISTICS: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_GET_STATISTICS;
pub const DECODER_OPTION_GET_SAR_INFO: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_GET_SAR_INFO;
pub const DECODER_OPTION_PROFILE: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_PROFILE;
pub const DECODER_OPTION_LEVEL: _bindgen_ty_9 =
    _bindgen_ty_9::DECODER_OPTION_LEVEL;
#[repr(u32)]
/**
* @brief Option types introduced in decoder application
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    DECODER_OPTION_END_OF_STREAM = 1,
    DECODER_OPTION_VCL_NAL = 2,
    DECODER_OPTION_TEMPORAL_ID = 3,
    DECODER_OPTION_FRAME_NUM = 4,
    DECODER_OPTION_IDR_PIC_ID = 5,
    DECODER_OPTION_LTR_MARKING_FLAG = 6,
    DECODER_OPTION_LTR_MARKED_FRAME_NUM = 7,
    DECODER_OPTION_ERROR_CON_IDC = 8,
    DECODER_OPTION_TRACE_LEVEL = 9,
    DECODER_OPTION_TRACE_CALLBACK = 10,
    DECODER_OPTION_TRACE_CALLBACK_CONTEXT = 11,
    DECODER_OPTION_GET_STATISTICS = 12,
    DECODER_OPTION_GET_SAR_INFO = 13,
    DECODER_OPTION_PROFILE = 14,
    DECODER_OPTION_LEVEL = 15,
}
pub use self::_bindgen_ty_9 as DECODER_OPTION;
pub const ERROR_CON_DISABLE: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_DISABLE;
pub const ERROR_CON_FRAME_COPY: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_FRAME_COPY;
pub const ERROR_CON_SLICE_COPY: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_SLICE_COPY;
pub const ERROR_CON_FRAME_COPY_CROSS_IDR: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_FRAME_COPY_CROSS_IDR;
pub const ERROR_CON_SLICE_COPY_CROSS_IDR: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_SLICE_COPY_CROSS_IDR;
pub const ERROR_CON_SLICE_COPY_CROSS_IDR_FREEZE_RES_CHANGE: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_SLICE_COPY_CROSS_IDR_FREEZE_RES_CHANGE;
pub const ERROR_CON_SLICE_MV_COPY_CROSS_IDR: _bindgen_ty_10 =
    _bindgen_ty_10::ERROR_CON_SLICE_MV_COPY_CROSS_IDR;
pub const ERROR_CON_SLICE_MV_COPY_CROSS_IDR_FREEZE_RES_CHANGE: _bindgen_ty_10
          =
    _bindgen_ty_10::ERROR_CON_SLICE_MV_COPY_CROSS_IDR_FREEZE_RES_CHANGE;
#[repr(u32)]
/**
* @brief Enumerate the type of error concealment methods
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    ERROR_CON_DISABLE = 0,
    ERROR_CON_FRAME_COPY = 1,
    ERROR_CON_SLICE_COPY = 2,
    ERROR_CON_FRAME_COPY_CROSS_IDR = 3,
    ERROR_CON_SLICE_COPY_CROSS_IDR = 4,
    ERROR_CON_SLICE_COPY_CROSS_IDR_FREEZE_RES_CHANGE = 5,
    ERROR_CON_SLICE_MV_COPY_CROSS_IDR = 6,
    ERROR_CON_SLICE_MV_COPY_CROSS_IDR_FREEZE_RES_CHANGE = 7,
}
pub use self::_bindgen_ty_10 as ERROR_CON_IDC;
pub const FEEDBACK_NON_VCL_NAL: _bindgen_ty_11 =
    _bindgen_ty_11::FEEDBACK_NON_VCL_NAL;
pub const FEEDBACK_VCL_NAL: _bindgen_ty_11 = _bindgen_ty_11::FEEDBACK_VCL_NAL;
pub const FEEDBACK_UNKNOWN_NAL: _bindgen_ty_11 =
    _bindgen_ty_11::FEEDBACK_UNKNOWN_NAL;
#[repr(u32)]
/**
* @brief Feedback that whether or not have VCL NAL in current AU
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    FEEDBACK_NON_VCL_NAL = 0,
    FEEDBACK_VCL_NAL = 1,
    FEEDBACK_UNKNOWN_NAL = 2,
}
pub use self::_bindgen_ty_11 as FEEDBACK_VCL_NAL_IN_AU;
pub const NON_VIDEO_CODING_LAYER: _bindgen_ty_12 =
    _bindgen_ty_12::NON_VIDEO_CODING_LAYER;
pub const VIDEO_CODING_LAYER: _bindgen_ty_12 =
    _bindgen_ty_12::VIDEO_CODING_LAYER;
#[repr(u32)]
/**
* @brief Type of layer being encoded
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    NON_VIDEO_CODING_LAYER = 0,
    VIDEO_CODING_LAYER = 1,
}
pub use self::_bindgen_ty_12 as LAYER_TYPE;
pub const SPATIAL_LAYER_0: _bindgen_ty_13 = _bindgen_ty_13::SPATIAL_LAYER_0;
pub const SPATIAL_LAYER_1: _bindgen_ty_13 = _bindgen_ty_13::SPATIAL_LAYER_1;
pub const SPATIAL_LAYER_2: _bindgen_ty_13 = _bindgen_ty_13::SPATIAL_LAYER_2;
pub const SPATIAL_LAYER_3: _bindgen_ty_13 = _bindgen_ty_13::SPATIAL_LAYER_3;
pub const SPATIAL_LAYER_ALL: _bindgen_ty_13 =
    _bindgen_ty_13::SPATIAL_LAYER_ALL;
#[repr(u32)]
/**
* @brief Spatial layer num
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    SPATIAL_LAYER_0 = 0,
    SPATIAL_LAYER_1 = 1,
    SPATIAL_LAYER_2 = 2,
    SPATIAL_LAYER_3 = 3,
    SPATIAL_LAYER_ALL = 4,
}
pub use self::_bindgen_ty_13 as LAYER_NUM;
pub const VIDEO_BITSTREAM_AVC: _bindgen_ty_14 =
    _bindgen_ty_14::VIDEO_BITSTREAM_AVC;
pub const VIDEO_BITSTREAM_SVC: _bindgen_ty_14 =
    _bindgen_ty_14::VIDEO_BITSTREAM_SVC;
pub const VIDEO_BITSTREAM_DEFAULT: _bindgen_ty_14 =
    _bindgen_ty_14::VIDEO_BITSTREAM_SVC;
#[repr(u32)]
/**
* @brief Enumerate the type of video bitstream which is provided to decoder
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 { VIDEO_BITSTREAM_AVC = 0, VIDEO_BITSTREAM_SVC = 1, }
pub use self::_bindgen_ty_14 as VIDEO_BITSTREAM_TYPE;
pub const NO_RECOVERY_REQUSET: _bindgen_ty_15 =
    _bindgen_ty_15::NO_RECOVERY_REQUSET;
pub const LTR_RECOVERY_REQUEST: _bindgen_ty_15 =
    _bindgen_ty_15::LTR_RECOVERY_REQUEST;
pub const IDR_RECOVERY_REQUEST: _bindgen_ty_15 =
    _bindgen_ty_15::IDR_RECOVERY_REQUEST;
pub const NO_LTR_MARKING_FEEDBACK: _bindgen_ty_15 =
    _bindgen_ty_15::NO_LTR_MARKING_FEEDBACK;
pub const LTR_MARKING_SUCCESS: _bindgen_ty_15 =
    _bindgen_ty_15::LTR_MARKING_SUCCESS;
pub const LTR_MARKING_FAILED: _bindgen_ty_15 =
    _bindgen_ty_15::LTR_MARKING_FAILED;
#[repr(u32)]
/**
* @brief Enumerate the type of key frame request
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    NO_RECOVERY_REQUSET = 0,
    LTR_RECOVERY_REQUEST = 1,
    IDR_RECOVERY_REQUEST = 2,
    NO_LTR_MARKING_FEEDBACK = 3,
    LTR_MARKING_SUCCESS = 4,
    LTR_MARKING_FAILED = 5,
}
pub use self::_bindgen_ty_15 as KEY_FRAME_REQUEST_TYPE;
/**
* @brief Structure for LTR recover request
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    ///< IDR request or LTR recovery request
    pub uiFeedbackType: ::std::os::raw::c_uint,
    ///< distinguish request from different IDR
    pub uiIDRPicId: ::std::os::raw::c_uint,
    pub iLastCorrectFrameNum: ::std::os::raw::c_int,
    ///< specify current decoder frame_num.
    pub iCurrentFrameNum: ::std::os::raw::c_int,
    pub iLayerId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 20usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 4usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub type SLTRRecoverRequest = _bindgen_ty_16;
/**
* @brief Structure for LTR marking feedback
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    ///< mark failed or successful
    pub uiFeedbackType: ::std::os::raw::c_uint,
    ///< distinguish request from different IDR
    pub uiIDRPicId: ::std::os::raw::c_uint,
    ///< specify current decoder frame_num
    pub iLTRFrameNum: ::std::os::raw::c_int,
    pub iLayerId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 4usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub type SLTRMarkingFeedback = _bindgen_ty_17;
/**
* @brief Structure for LTR configuration
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    ///< 1: on, 0: off
    pub bEnableLongTermReference: bool,
    ///< TODO: not supported to set it arbitrary yet
    pub iLTRRefNum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_18>() , 4usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub type SLTRConfig = _bindgen_ty_18;
pub const RC_QUALITY_MODE: _bindgen_ty_19 = _bindgen_ty_19::RC_QUALITY_MODE;
pub const RC_BITRATE_MODE: _bindgen_ty_19 = _bindgen_ty_19::RC_BITRATE_MODE;
pub const RC_BUFFERBASED_MODE: _bindgen_ty_19 =
    _bindgen_ty_19::RC_BUFFERBASED_MODE;
pub const RC_TIMESTAMP_MODE: _bindgen_ty_19 =
    _bindgen_ty_19::RC_TIMESTAMP_MODE;
pub const RC_BITRATE_MODE_POST_SKIP: _bindgen_ty_19 =
    _bindgen_ty_19::RC_BITRATE_MODE_POST_SKIP;
pub const RC_OFF_MODE: _bindgen_ty_19 = _bindgen_ty_19::RC_OFF_MODE;
#[repr(i32)]
/**
* @brief Enumerate the type of rate control mode
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    RC_QUALITY_MODE = 0,
    RC_BITRATE_MODE = 1,
    RC_BUFFERBASED_MODE = 2,
    RC_TIMESTAMP_MODE = 3,
    RC_BITRATE_MODE_POST_SKIP = 4,
    RC_OFF_MODE = -1,
}
pub use self::_bindgen_ty_19 as RC_MODES;
pub const PRO_UNKNOWN: _bindgen_ty_20 = _bindgen_ty_20::PRO_UNKNOWN;
pub const PRO_BASELINE: _bindgen_ty_20 = _bindgen_ty_20::PRO_BASELINE;
pub const PRO_MAIN: _bindgen_ty_20 = _bindgen_ty_20::PRO_MAIN;
pub const PRO_EXTENDED: _bindgen_ty_20 = _bindgen_ty_20::PRO_EXTENDED;
pub const PRO_HIGH: _bindgen_ty_20 = _bindgen_ty_20::PRO_HIGH;
pub const PRO_HIGH10: _bindgen_ty_20 = _bindgen_ty_20::PRO_HIGH10;
pub const PRO_HIGH422: _bindgen_ty_20 = _bindgen_ty_20::PRO_HIGH422;
pub const PRO_HIGH444: _bindgen_ty_20 = _bindgen_ty_20::PRO_HIGH444;
pub const PRO_CAVLC444: _bindgen_ty_20 = _bindgen_ty_20::PRO_CAVLC444;
pub const PRO_SCALABLE_BASELINE: _bindgen_ty_20 =
    _bindgen_ty_20::PRO_SCALABLE_BASELINE;
pub const PRO_SCALABLE_HIGH: _bindgen_ty_20 =
    _bindgen_ty_20::PRO_SCALABLE_HIGH;
#[repr(u32)]
/**
* @brief Enumerate the type of profile id
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    PRO_UNKNOWN = 0,
    PRO_BASELINE = 66,
    PRO_MAIN = 77,
    PRO_EXTENDED = 88,
    PRO_HIGH = 100,
    PRO_HIGH10 = 110,
    PRO_HIGH422 = 122,
    PRO_HIGH444 = 144,
    PRO_CAVLC444 = 244,
    PRO_SCALABLE_BASELINE = 83,
    PRO_SCALABLE_HIGH = 86,
}
pub use self::_bindgen_ty_20 as EProfileIdc;
pub const LEVEL_UNKNOWN: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_UNKNOWN;
pub const LEVEL_1_0: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_1_0;
pub const LEVEL_1_B: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_1_B;
pub const LEVEL_1_1: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_1_1;
pub const LEVEL_1_2: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_1_2;
pub const LEVEL_1_3: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_1_3;
pub const LEVEL_2_0: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_2_0;
pub const LEVEL_2_1: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_2_1;
pub const LEVEL_2_2: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_2_2;
pub const LEVEL_3_0: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_3_0;
pub const LEVEL_3_1: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_3_1;
pub const LEVEL_3_2: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_3_2;
pub const LEVEL_4_0: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_4_0;
pub const LEVEL_4_1: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_4_1;
pub const LEVEL_4_2: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_4_2;
pub const LEVEL_5_0: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_5_0;
pub const LEVEL_5_1: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_5_1;
pub const LEVEL_5_2: _bindgen_ty_21 = _bindgen_ty_21::LEVEL_5_2;
#[repr(u32)]
/**
* @brief Enumerate the type of level id
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_21 {
    LEVEL_UNKNOWN = 0,
    LEVEL_1_0 = 10,
    LEVEL_1_B = 9,
    LEVEL_1_1 = 11,
    LEVEL_1_2 = 12,
    LEVEL_1_3 = 13,
    LEVEL_2_0 = 20,
    LEVEL_2_1 = 21,
    LEVEL_2_2 = 22,
    LEVEL_3_0 = 30,
    LEVEL_3_1 = 31,
    LEVEL_3_2 = 32,
    LEVEL_4_0 = 40,
    LEVEL_4_1 = 41,
    LEVEL_4_2 = 42,
    LEVEL_5_0 = 50,
    LEVEL_5_1 = 51,
    LEVEL_5_2 = 52,
}
pub use self::_bindgen_ty_21 as ELevelIdc;
pub const WELS_LOG_QUIET: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_QUIET;
pub const WELS_LOG_ERROR: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_ERROR;
pub const WELS_LOG_WARNING: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_WARNING;
pub const WELS_LOG_INFO: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_INFO;
pub const WELS_LOG_DEBUG: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_DEBUG;
pub const WELS_LOG_DETAIL: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_DETAIL;
pub const WELS_LOG_RESV: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_RESV;
pub const WELS_LOG_LEVEL_COUNT: _bindgen_ty_22 =
    _bindgen_ty_22::WELS_LOG_LEVEL_COUNT;
pub const WELS_LOG_DEFAULT: _bindgen_ty_22 = _bindgen_ty_22::WELS_LOG_WARNING;
#[repr(u32)]
/**
* @brief Enumerate the type of wels log
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    WELS_LOG_QUIET = 0,
    WELS_LOG_ERROR = 1,
    WELS_LOG_WARNING = 2,
    WELS_LOG_INFO = 4,
    WELS_LOG_DEBUG = 8,
    WELS_LOG_DETAIL = 16,
    WELS_LOG_RESV = 32,
    WELS_LOG_LEVEL_COUNT = 6,
}
pub const SM_SINGLE_SLICE: _bindgen_ty_23 = _bindgen_ty_23::SM_SINGLE_SLICE;
pub const SM_FIXEDSLCNUM_SLICE: _bindgen_ty_23 =
    _bindgen_ty_23::SM_FIXEDSLCNUM_SLICE;
pub const SM_RASTER_SLICE: _bindgen_ty_23 = _bindgen_ty_23::SM_RASTER_SLICE;
pub const SM_SIZELIMITED_SLICE: _bindgen_ty_23 =
    _bindgen_ty_23::SM_SIZELIMITED_SLICE;
pub const SM_RESERVED: _bindgen_ty_23 = _bindgen_ty_23::SM_RESERVED;
#[repr(u32)]
/**
 * @brief Enumerate the type of slice mode
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    SM_SINGLE_SLICE = 0,
    SM_FIXEDSLCNUM_SLICE = 1,
    SM_RASTER_SLICE = 2,
    SM_SIZELIMITED_SLICE = 3,
    SM_RESERVED = 4,
}
pub use self::_bindgen_ty_23 as SliceModeEnum;
/**
 * @brief Structure for slice argument
 */
#[repr(C)]
pub struct _bindgen_ty_24 {
    ///< by default, uiSliceMode will be SM_SINGLE_SLICE
    pub uiSliceMode: SliceModeEnum,
    ///< only used when uiSliceMode=1, when uiSliceNum=0 means auto design it with cpu core number
    pub uiSliceNum: ::std::os::raw::c_uint,
    ///< only used when uiSliceMode=2; when =0 means setting one MB row a slice
    pub uiSliceMbNum: [::std::os::raw::c_uint; 35usize],
    ///< now only used when uiSliceMode=4
    pub uiSliceSizeConstraint: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_24() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_24>() , 152usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_24>() , 4usize);
}
pub type SSliceArgument = _bindgen_ty_24;
pub const VF_COMPONENT: _bindgen_ty_25 = _bindgen_ty_25::VF_COMPONENT;
pub const VF_PAL: _bindgen_ty_25 = _bindgen_ty_25::VF_PAL;
pub const VF_NTSC: _bindgen_ty_25 = _bindgen_ty_25::VF_NTSC;
pub const VF_SECAM: _bindgen_ty_25 = _bindgen_ty_25::VF_SECAM;
pub const VF_MAC: _bindgen_ty_25 = _bindgen_ty_25::VF_MAC;
pub const VF_UNDEF: _bindgen_ty_25 = _bindgen_ty_25::VF_UNDEF;
pub const VF_NUM_ENUM: _bindgen_ty_25 = _bindgen_ty_25::VF_NUM_ENUM;
#[repr(u32)]
/**
* @brief Enumerate the type of video format
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    VF_COMPONENT = 0,
    VF_PAL = 1,
    VF_NTSC = 2,
    VF_SECAM = 3,
    VF_MAC = 4,
    VF_UNDEF = 5,
    VF_NUM_ENUM = 6,
}
pub use self::_bindgen_ty_25 as EVideoFormatSPS;
pub const CP_RESERVED0: _bindgen_ty_26 = _bindgen_ty_26::CP_RESERVED0;
pub const CP_BT709: _bindgen_ty_26 = _bindgen_ty_26::CP_BT709;
pub const CP_UNDEF: _bindgen_ty_26 = _bindgen_ty_26::CP_UNDEF;
pub const CP_RESERVED3: _bindgen_ty_26 = _bindgen_ty_26::CP_RESERVED3;
pub const CP_BT470M: _bindgen_ty_26 = _bindgen_ty_26::CP_BT470M;
pub const CP_BT470BG: _bindgen_ty_26 = _bindgen_ty_26::CP_BT470BG;
pub const CP_SMPTE170M: _bindgen_ty_26 = _bindgen_ty_26::CP_SMPTE170M;
pub const CP_SMPTE240M: _bindgen_ty_26 = _bindgen_ty_26::CP_SMPTE240M;
pub const CP_FILM: _bindgen_ty_26 = _bindgen_ty_26::CP_FILM;
pub const CP_BT2020: _bindgen_ty_26 = _bindgen_ty_26::CP_BT2020;
pub const CP_NUM_ENUM: _bindgen_ty_26 = _bindgen_ty_26::CP_NUM_ENUM;
#[repr(u32)]
/**
* @brief Enumerate the type of color primaries
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 {
    CP_RESERVED0 = 0,
    CP_BT709 = 1,
    CP_UNDEF = 2,
    CP_RESERVED3 = 3,
    CP_BT470M = 4,
    CP_BT470BG = 5,
    CP_SMPTE170M = 6,
    CP_SMPTE240M = 7,
    CP_FILM = 8,
    CP_BT2020 = 9,
    CP_NUM_ENUM = 10,
}
pub use self::_bindgen_ty_26 as EColorPrimaries;
pub const TRC_RESERVED0: _bindgen_ty_27 = _bindgen_ty_27::TRC_RESERVED0;
pub const TRC_BT709: _bindgen_ty_27 = _bindgen_ty_27::TRC_BT709;
pub const TRC_UNDEF: _bindgen_ty_27 = _bindgen_ty_27::TRC_UNDEF;
pub const TRC_RESERVED3: _bindgen_ty_27 = _bindgen_ty_27::TRC_RESERVED3;
pub const TRC_BT470M: _bindgen_ty_27 = _bindgen_ty_27::TRC_BT470M;
pub const TRC_BT470BG: _bindgen_ty_27 = _bindgen_ty_27::TRC_BT470BG;
pub const TRC_SMPTE170M: _bindgen_ty_27 = _bindgen_ty_27::TRC_SMPTE170M;
pub const TRC_SMPTE240M: _bindgen_ty_27 = _bindgen_ty_27::TRC_SMPTE240M;
pub const TRC_LINEAR: _bindgen_ty_27 = _bindgen_ty_27::TRC_LINEAR;
pub const TRC_LOG100: _bindgen_ty_27 = _bindgen_ty_27::TRC_LOG100;
pub const TRC_LOG316: _bindgen_ty_27 = _bindgen_ty_27::TRC_LOG316;
pub const TRC_IEC61966_2_4: _bindgen_ty_27 = _bindgen_ty_27::TRC_IEC61966_2_4;
pub const TRC_BT1361E: _bindgen_ty_27 = _bindgen_ty_27::TRC_BT1361E;
pub const TRC_IEC61966_2_1: _bindgen_ty_27 = _bindgen_ty_27::TRC_IEC61966_2_1;
pub const TRC_BT2020_10: _bindgen_ty_27 = _bindgen_ty_27::TRC_BT2020_10;
pub const TRC_BT2020_12: _bindgen_ty_27 = _bindgen_ty_27::TRC_BT2020_12;
pub const TRC_NUM_ENUM: _bindgen_ty_27 = _bindgen_ty_27::TRC_NUM_ENUM;
#[repr(u32)]
/**
* @brief Enumerate the type of transfer characteristics
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 {
    TRC_RESERVED0 = 0,
    TRC_BT709 = 1,
    TRC_UNDEF = 2,
    TRC_RESERVED3 = 3,
    TRC_BT470M = 4,
    TRC_BT470BG = 5,
    TRC_SMPTE170M = 6,
    TRC_SMPTE240M = 7,
    TRC_LINEAR = 8,
    TRC_LOG100 = 9,
    TRC_LOG316 = 10,
    TRC_IEC61966_2_4 = 11,
    TRC_BT1361E = 12,
    TRC_IEC61966_2_1 = 13,
    TRC_BT2020_10 = 14,
    TRC_BT2020_12 = 15,
    TRC_NUM_ENUM = 16,
}
pub use self::_bindgen_ty_27 as ETransferCharacteristics;
pub const CM_GBR: _bindgen_ty_28 = _bindgen_ty_28::CM_GBR;
pub const CM_BT709: _bindgen_ty_28 = _bindgen_ty_28::CM_BT709;
pub const CM_UNDEF: _bindgen_ty_28 = _bindgen_ty_28::CM_UNDEF;
pub const CM_RESERVED3: _bindgen_ty_28 = _bindgen_ty_28::CM_RESERVED3;
pub const CM_FCC: _bindgen_ty_28 = _bindgen_ty_28::CM_FCC;
pub const CM_BT470BG: _bindgen_ty_28 = _bindgen_ty_28::CM_BT470BG;
pub const CM_SMPTE170M: _bindgen_ty_28 = _bindgen_ty_28::CM_SMPTE170M;
pub const CM_SMPTE240M: _bindgen_ty_28 = _bindgen_ty_28::CM_SMPTE240M;
pub const CM_YCGCO: _bindgen_ty_28 = _bindgen_ty_28::CM_YCGCO;
pub const CM_BT2020NC: _bindgen_ty_28 = _bindgen_ty_28::CM_BT2020NC;
pub const CM_BT2020C: _bindgen_ty_28 = _bindgen_ty_28::CM_BT2020C;
pub const CM_NUM_ENUM: _bindgen_ty_28 = _bindgen_ty_28::CM_NUM_ENUM;
#[repr(u32)]
/**
* @brief Enumerate the type of color matrix
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 {
    CM_GBR = 0,
    CM_BT709 = 1,
    CM_UNDEF = 2,
    CM_RESERVED3 = 3,
    CM_FCC = 4,
    CM_BT470BG = 5,
    CM_SMPTE170M = 6,
    CM_SMPTE240M = 7,
    CM_YCGCO = 8,
    CM_BT2020NC = 9,
    CM_BT2020C = 10,
    CM_NUM_ENUM = 11,
}
pub use self::_bindgen_ty_28 as EColorMatrix;
pub const ASP_UNSPECIFIED: _bindgen_ty_29 = _bindgen_ty_29::ASP_UNSPECIFIED;
pub const ASP_1x1: _bindgen_ty_29 = _bindgen_ty_29::ASP_1x1;
pub const ASP_12x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_12x11;
pub const ASP_10x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_10x11;
pub const ASP_16x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_16x11;
pub const ASP_40x33: _bindgen_ty_29 = _bindgen_ty_29::ASP_40x33;
pub const ASP_24x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_24x11;
pub const ASP_20x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_20x11;
pub const ASP_32x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_32x11;
pub const ASP_80x33: _bindgen_ty_29 = _bindgen_ty_29::ASP_80x33;
pub const ASP_18x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_18x11;
pub const ASP_15x11: _bindgen_ty_29 = _bindgen_ty_29::ASP_15x11;
pub const ASP_64x33: _bindgen_ty_29 = _bindgen_ty_29::ASP_64x33;
pub const ASP_160x99: _bindgen_ty_29 = _bindgen_ty_29::ASP_160x99;
pub const ASP_EXT_SAR: _bindgen_ty_29 = _bindgen_ty_29::ASP_EXT_SAR;
#[repr(u32)]
/**
* @brief Enumerate the type of sample aspect ratio
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_29 {
    ASP_UNSPECIFIED = 0,
    ASP_1x1 = 1,
    ASP_12x11 = 2,
    ASP_10x11 = 3,
    ASP_16x11 = 4,
    ASP_40x33 = 5,
    ASP_24x11 = 6,
    ASP_20x11 = 7,
    ASP_32x11 = 8,
    ASP_80x33 = 9,
    ASP_18x11 = 10,
    ASP_15x11 = 11,
    ASP_64x33 = 12,
    ASP_160x99 = 13,
    ASP_EXT_SAR = 255,
}
pub use self::_bindgen_ty_29 as ESampleAspectRatio;
/**
* @brief  Structure for spatial layer configuration
*/
#[repr(C)]
pub struct _bindgen_ty_30 {
    ///< width of picture in luminance samples of a layer
    pub iVideoWidth: ::std::os::raw::c_int,
    ///< height of picture in luminance samples of a layer
    pub iVideoHeight: ::std::os::raw::c_int,
    ///< frame rate specified for a layer
    pub fFrameRate: f32,
    ///< target bitrate for a spatial layer, in unit of bps
    pub iSpatialBitrate: ::std::os::raw::c_int,
    ///< maximum  bitrate for a spatial layer, in unit of bps
    pub iMaxSpatialBitrate: ::std::os::raw::c_int,
    ///< value of profile IDC (PRO_UNKNOWN for auto-detection)
    pub uiProfileIdc: EProfileIdc,
    ///< value of profile IDC (0 for auto-detection)
    pub uiLevelIdc: ELevelIdc,
    ///< value of level IDC (0 for auto-detection)
    pub iDLayerQp: ::std::os::raw::c_int,
    pub sSliceArgument: SSliceArgument,
    pub bVideoSignalTypePresent: bool,
    pub uiVideoFormat: ::std::os::raw::c_uchar,
    pub bFullRange: bool,
    pub bColorDescriptionPresent: bool,
    pub uiColorPrimaries: ::std::os::raw::c_uchar,
    pub uiTransferCharacteristics: ::std::os::raw::c_uchar,
    pub uiColorMatrix: ::std::os::raw::c_uchar,
    ///< aspect ratio present in VUI
    pub bAspectRatioPresent: bool,
    ///< aspect ratio idc
    pub eAspectRatio: ESampleAspectRatio,
    ///< use if aspect ratio idc == 255
    pub sAspectRatioExtWidth: ::std::os::raw::c_ushort,
    ///< use if aspect ratio idc == 255
    pub sAspectRatioExtHeight: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__bindgen_ty_30() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_30>() , 200usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_30>() , 4usize);
}
pub type SSpatialLayerConfig = _bindgen_ty_30;
pub const CAMERA_VIDEO_REAL_TIME: _bindgen_ty_31 =
    _bindgen_ty_31::CAMERA_VIDEO_REAL_TIME;
pub const SCREEN_CONTENT_REAL_TIME: _bindgen_ty_31 =
    _bindgen_ty_31::SCREEN_CONTENT_REAL_TIME;
pub const CAMERA_VIDEO_NON_REAL_TIME: _bindgen_ty_31 =
    _bindgen_ty_31::CAMERA_VIDEO_NON_REAL_TIME;
#[repr(u32)]
/**
* @brief Encoder usage type
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_31 {
    CAMERA_VIDEO_REAL_TIME = 0,
    SCREEN_CONTENT_REAL_TIME = 1,
    CAMERA_VIDEO_NON_REAL_TIME = 2,
}
pub use self::_bindgen_ty_31 as EUsageType;
pub const LOW_COMPLEXITY: _bindgen_ty_32 = _bindgen_ty_32::LOW_COMPLEXITY;
pub const MEDIUM_COMPLEXITY: _bindgen_ty_32 =
    _bindgen_ty_32::MEDIUM_COMPLEXITY;
pub const HIGH_COMPLEXITY: _bindgen_ty_32 = _bindgen_ty_32::HIGH_COMPLEXITY;
#[repr(u32)]
/**
* @brief Enumulate the complexity mode
*/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_32 {
    LOW_COMPLEXITY = 0,
    MEDIUM_COMPLEXITY = 1,
    HIGH_COMPLEXITY = 2,
}
pub use self::_bindgen_ty_32 as ECOMPLEXITY_MODE;
pub const CONSTANT_ID: _bindgen_ty_33 = _bindgen_ty_33::CONSTANT_ID;
pub const INCREASING_ID: _bindgen_ty_33 = _bindgen_ty_33::INCREASING_ID;
pub const SPS_LISTING: _bindgen_ty_33 = _bindgen_ty_33::SPS_LISTING;
pub const SPS_LISTING_AND_PPS_INCREASING: _bindgen_ty_33 =
    _bindgen_ty_33::SPS_LISTING_AND_PPS_INCREASING;
pub const SPS_PPS_LISTING: _bindgen_ty_33 = _bindgen_ty_33::SPS_PPS_LISTING;
#[repr(u32)]
/**
 * @brief Enumulate for the stategy of SPS/PPS strategy
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_33 {
    CONSTANT_ID = 0,
    INCREASING_ID = 1,
    SPS_LISTING = 2,
    SPS_LISTING_AND_PPS_INCREASING = 3,
    SPS_PPS_LISTING = 6,
}
pub use self::_bindgen_ty_33 as EParameterSetStrategy;
/**
* @brief SVC Encoding Parameters
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagEncParamBase {
    ///< application type;1.CAMERA_VIDEO_REAL_TIME:camera video signal; 2.SCREEN_CONTENT_REAL_TIME:screen content signal;
    pub iUsageType: EUsageType,
    ///< width of picture in luminance samples (the maximum of all layers if multiple spatial layers presents)
    pub iPicWidth: ::std::os::raw::c_int,
    ///< height of picture in luminance samples((the maximum of all layers if multiple spatial layers presents)
    pub iPicHeight: ::std::os::raw::c_int,
    ///< target bitrate desired, in unit of bps
    pub iTargetBitrate: ::std::os::raw::c_int,
    ///< rate control mode
    pub iRCMode: RC_MODES,
    ///< maximal input frame rate
    pub fMaxFrameRate: f32,
}
#[test]
fn bindgen_test_layout_TagEncParamBase() {
    assert_eq!(::std::mem::size_of::<TagEncParamBase>() , 24usize);
    assert_eq!(::std::mem::align_of::<TagEncParamBase>() , 4usize);
}
impl Clone for TagEncParamBase {
    fn clone(&self) -> Self { *self }
}
pub type SEncParamBase = TagEncParamBase;
pub type PEncParamBase = *mut TagEncParamBase;
/**
* @brief SVC Encoding Parameters extention
*/
#[repr(C)]
pub struct TagEncParamExt {
    ///< application type;1.CAMERA_VIDEO_REAL_TIME:camera video signal;2.SCREEN_CONTENT_REAL_TIME:screen content signal;
    pub iUsageType: EUsageType,
    ///< width of picture in luminance samples (the maximum of all layers if multiple spatial layers presents)
    pub iPicWidth: ::std::os::raw::c_int,
    ///< height of picture in luminance samples((the maximum of all layers if multiple spatial layers presents)
    pub iPicHeight: ::std::os::raw::c_int,
    ///< target bitrate desired, in unit of bps
    pub iTargetBitrate: ::std::os::raw::c_int,
    ///< rate control mode
    pub iRCMode: RC_MODES,
    ///< maximal input frame rate
    pub fMaxFrameRate: f32,
    ///< temporal layer number, max temporal layer = 4
    pub iTemporalLayerNum: ::std::os::raw::c_int,
    ///< spatial layer number,1<= iSpatialLayerNum <= MAX_SPATIAL_LAYER_NUM, MAX_SPATIAL_LAYER_NUM = 4
    pub iSpatialLayerNum: ::std::os::raw::c_int,
    pub sSpatialLayers: [SSpatialLayerConfig; 4usize],
    pub iComplexityMode: ECOMPLEXITY_MODE,
    ///< period of Intra frame
    pub uiIntraPeriod: ::std::os::raw::c_uint,
    ///< number of reference frame used
    pub iNumRefFrame: ::std::os::raw::c_int,
    ///< different stategy in adjust ID in SPS/PPS: 0- constant ID, 1-additional ID, 6-mapping and additional
    pub eSpsPpsIdStrategy: EParameterSetStrategy,
    ///< false:not use Prefix NAL; true: use Prefix NAL
    pub bPrefixNalAddingCtrl: bool,
    ///< false:not use SSEI; true: use SSEI -- TODO: planning to remove the interface of SSEI
    pub bEnableSSEI: bool,
    ///< (when encoding more than 1 spatial layer) false: use SVC syntax for higher layers; true: use Simulcast AVC
    pub bSimulcastAVC: bool,
    ///< 0:disable padding;1:padding
    pub iPaddingFlag: ::std::os::raw::c_int,
    ///< 0:CAVLC  1:CABAC.
    pub iEntropyCodingModeFlag: ::std::os::raw::c_int,
    ///< False: don't skip frame even if VBV buffer overflow.True: allow skipping frames to keep the bitrate within limits
    pub bEnableFrameSkip: bool,
    ///< the maximum bitrate, in unit of bps, set it to UNSPECIFIED_BIT_RATE if not needed
    pub iMaxBitrate: ::std::os::raw::c_int,
    ///< the maximum QP encoder supports
    pub iMaxQp: ::std::os::raw::c_int,
    ///< the minmum QP encoder supports
    pub iMinQp: ::std::os::raw::c_int,
    ///< the maximum NAL size.  This value should be not 0 for dynamic slice mode
    pub uiMaxNalSize: ::std::os::raw::c_uint,
    ///< 1: on, 0: off
    pub bEnableLongTermReference: bool,
    ///< the number of LTR(long term reference),TODO: not supported to set it arbitrary yet
    pub iLTRRefNum: ::std::os::raw::c_int,
    ///< the LTR marked period that is used in feedback.
    pub iLtrMarkPeriod: ::std::os::raw::c_uint,
    ///< 1 # 0: auto(dynamic imp. internal encoder); 1: multiple threads imp. disabled; lager than 1: count number of threads;
    pub iMultipleThreadIdc: ::std::os::raw::c_ushort,
    ///< only used when uiSliceMode=1 or 3, will change slicing of a picture during the run-time of multi-thread encoding, so the result of each run may be different
    pub bUseLoadBalancing: bool,
    ///< 0: on, 1: off, 2: on except for slice boundaries
    pub iLoopFilterDisableIdc: ::std::os::raw::c_int,
    ///< AlphaOffset: valid range [-6, 6], default 0
    pub iLoopFilterAlphaC0Offset: ::std::os::raw::c_int,
    ///< BetaOffset: valid range [-6, 6], default 0
    pub iLoopFilterBetaOffset: ::std::os::raw::c_int,
    ///< denoise control
    pub bEnableDenoise: bool,
    ///< background detection control //VAA_BACKGROUND_DETECTION //BGD cmd
    pub bEnableBackgroundDetection: bool,
    ///< adaptive quantization control
    pub bEnableAdaptiveQuant: bool,
    ///< enable frame cropping flag: TRUE always in application
    pub bEnableFrameCroppingFlag: bool,
    pub bEnableSceneChangeDetect: bool,
    ///<  LTR advanced setting
    pub bIsLosslessLink: bool,
}
#[test]
fn bindgen_test_layout_TagEncParamExt() {
    assert_eq!(::std::mem::size_of::<TagEncParamExt>() , 916usize);
    assert_eq!(::std::mem::align_of::<TagEncParamExt>() , 4usize);
}
pub type SEncParamExt = TagEncParamExt;
/**
* @brief Define a new struct to show the property of video bitstream.
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_34 {
    ///< size of the struct
    pub size: ::std::os::raw::c_uint,
    ///< video stream type (AVC/SVC)
    pub eVideoBsType: VIDEO_BITSTREAM_TYPE,
}
#[test]
fn bindgen_test_layout__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_34>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_34>() , 4usize);
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
pub type SVideoProperty = _bindgen_ty_34;
/**
* @brief SVC Decoding Parameters, reserved here and potential applicable in the future
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagSVCDecodingParam {
    ///< file name of reconstructed frame used for PSNR calculation based debug
    pub pFileNameRestructed: *mut ::std::os::raw::c_char,
    ///< CPU load
    pub uiCpuLoad: ::std::os::raw::c_uint,
    ///< setting target dq layer id
    pub uiTargetDqLayer: ::std::os::raw::c_uchar,
    ///< whether active error concealment feature in decoder
    pub eEcActiveIdc: ERROR_CON_IDC,
    ///< decoder for parse only, no reconstruction. When it is true, SPS/PPS size should not exceed SPS_PPS_BS_SIZE (128). Otherwise, it will return error info
    pub bParseOnly: bool,
    ///< video stream property
    pub sVideoProperty: SVideoProperty,
}
#[test]
fn bindgen_test_layout_TagSVCDecodingParam() {
    assert_eq!(::std::mem::size_of::<TagSVCDecodingParam>() , 32usize);
    assert_eq!(::std::mem::align_of::<TagSVCDecodingParam>() , 8usize);
}
impl Clone for TagSVCDecodingParam {
    fn clone(&self) -> Self { *self }
}
pub type SDecodingParam = TagSVCDecodingParam;
pub type PDecodingParam = *mut TagSVCDecodingParam;
/**
* @brief Bitstream inforamtion of a layer being encoded
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_35 {
    pub uiTemporalId: ::std::os::raw::c_uchar,
    pub uiSpatialId: ::std::os::raw::c_uchar,
    pub uiQualityId: ::std::os::raw::c_uchar,
    pub eFrameType: EVideoFrameType,
    pub uiLayerType: ::std::os::raw::c_uchar,
    ///< refer to D.2.11 Sub-sequence information SEI message semantics
    pub iSubSeqId: ::std::os::raw::c_int,
    ///< count number of NAL coded already
    pub iNalCount: ::std::os::raw::c_int,
    ///< length of NAL size in byte from 0 to iNalCount-1
    pub pNalLengthInByte: *mut ::std::os::raw::c_int,
    ///< buffer of bitstream contained
    pub pBsBuf: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout__bindgen_ty_35() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_35>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_35>() , 8usize);
}
impl Clone for _bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
pub type SLayerBSInfo = _bindgen_ty_35;
pub type PLayerBSInfo = *mut _bindgen_ty_35;
/**
* @brief Frame bit stream info
*/
#[repr(C)]
pub struct _bindgen_ty_36 {
    pub iLayerNum: ::std::os::raw::c_int,
    pub sLayerInfo: [SLayerBSInfo; 128usize],
    pub eFrameType: EVideoFrameType,
    pub iFrameSizeInBytes: ::std::os::raw::c_int,
    pub uiTimeStamp: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_36() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_36>() , 5144usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_36>() , 8usize);
}
pub type SFrameBSInfo = _bindgen_ty_36;
pub type PFrameBSInfo = *mut _bindgen_ty_36;
/**
*  @brief Structure for source picture
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Source_Picture_s {
    ///< color space type
    pub iColorFormat: ::std::os::raw::c_int,
    ///< stride for each plane pData
    pub iStride: [::std::os::raw::c_int; 4usize],
    ///< plane pData
    pub pData: [*mut ::std::os::raw::c_uchar; 4usize],
    ///< luma picture width in x coordinate
    pub iPicWidth: ::std::os::raw::c_int,
    ///< luma picture height in y coordinate
    pub iPicHeight: ::std::os::raw::c_int,
    ///< timestamp of the source picture, unit: millisecond
    pub uiTimeStamp: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_Source_Picture_s() {
    assert_eq!(::std::mem::size_of::<Source_Picture_s>() , 72usize);
    assert_eq!(::std::mem::align_of::<Source_Picture_s>() , 8usize);
}
impl Clone for Source_Picture_s {
    fn clone(&self) -> Self { *self }
}
pub type SSourcePicture = Source_Picture_s;
/**
* @brief Structure for bit rate info
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagBitrateInfo {
    pub iLayer: LAYER_NUM,
    ///< the maximum bitrate
    pub iBitrate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TagBitrateInfo() {
    assert_eq!(::std::mem::size_of::<TagBitrateInfo>() , 8usize);
    assert_eq!(::std::mem::align_of::<TagBitrateInfo>() , 4usize);
}
impl Clone for TagBitrateInfo {
    fn clone(&self) -> Self { *self }
}
pub type SBitrateInfo = TagBitrateInfo;
/**
* @brief Structure for dump layer info
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagDumpLayer {
    pub iLayer: ::std::os::raw::c_int,
    pub pFileName: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_TagDumpLayer() {
    assert_eq!(::std::mem::size_of::<TagDumpLayer>() , 16usize);
    assert_eq!(::std::mem::align_of::<TagDumpLayer>() , 8usize);
}
impl Clone for TagDumpLayer {
    fn clone(&self) -> Self { *self }
}
pub type SDumpLayer = TagDumpLayer;
/**
* @brief Structure for profile info in layer
*
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagProfileInfo {
    pub iLayer: ::std::os::raw::c_int,
    ///< the profile info
    pub uiProfileIdc: EProfileIdc,
}
#[test]
fn bindgen_test_layout_TagProfileInfo() {
    assert_eq!(::std::mem::size_of::<TagProfileInfo>() , 8usize);
    assert_eq!(::std::mem::align_of::<TagProfileInfo>() , 4usize);
}
impl Clone for TagProfileInfo {
    fn clone(&self) -> Self { *self }
}
pub type SProfileInfo = TagProfileInfo;
/**
* @brief  Structure for level info in layer
*
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagLevelInfo {
    pub iLayer: ::std::os::raw::c_int,
    ///< the level info
    pub uiLevelIdc: ELevelIdc,
}
#[test]
fn bindgen_test_layout_TagLevelInfo() {
    assert_eq!(::std::mem::size_of::<TagLevelInfo>() , 8usize);
    assert_eq!(::std::mem::align_of::<TagLevelInfo>() , 4usize);
}
impl Clone for TagLevelInfo {
    fn clone(&self) -> Self { *self }
}
pub type SLevelInfo = TagLevelInfo;
/**
* @brief Structure for dilivery status
*
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagDeliveryStatus {
    ///< 0: the previous frame isn't delivered,1: the previous frame is delivered
    pub bDeliveryFlag: bool,
    ///< the frame type that is dropped; reserved
    pub iDropFrameType: ::std::os::raw::c_int,
    ///< the frame size that is dropped; reserved
    pub iDropFrameSize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TagDeliveryStatus() {
    assert_eq!(::std::mem::size_of::<TagDeliveryStatus>() , 12usize);
    assert_eq!(::std::mem::align_of::<TagDeliveryStatus>() , 4usize);
}
impl Clone for TagDeliveryStatus {
    fn clone(&self) -> Self { *self }
}
pub type SDeliveryStatus = TagDeliveryStatus;
/**
* @brief The capability of decoder, for SDP negotiation
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagDecoderCapability {
    ///< profile_idc
    pub iProfileIdc: ::std::os::raw::c_int,
    ///< profile-iop
    pub iProfileIop: ::std::os::raw::c_int,
    ///< level_idc
    pub iLevelIdc: ::std::os::raw::c_int,
    ///< max-mbps
    pub iMaxMbps: ::std::os::raw::c_int,
    ///< max-fs
    pub iMaxFs: ::std::os::raw::c_int,
    ///< max-cpb
    pub iMaxCpb: ::std::os::raw::c_int,
    ///< max-dpb
    pub iMaxDpb: ::std::os::raw::c_int,
    ///< max-br
    pub iMaxBr: ::std::os::raw::c_int,
    ///< redundant-pic-cap
    pub bRedPicCap: bool,
}
#[test]
fn bindgen_test_layout_TagDecoderCapability() {
    assert_eq!(::std::mem::size_of::<TagDecoderCapability>() , 36usize);
    assert_eq!(::std::mem::align_of::<TagDecoderCapability>() , 4usize);
}
impl Clone for TagDecoderCapability {
    fn clone(&self) -> Self { *self }
}
pub type SDecoderCapability = TagDecoderCapability;
/**
* @brief Structure for parse only output
*/
#[repr(C)]
pub struct TagParserBsInfo {
    ///< total NAL number in current AU
    pub iNalNum: ::std::os::raw::c_int,
    ///< each nal length
    pub iNalLenInByte: [::std::os::raw::c_int; 128usize],
    ///< outputted dst buffer for parsed bitstream
    pub pDstBuff: *mut ::std::os::raw::c_uchar,
    ///< required SPS width info
    pub iSpsWidthInPixel: ::std::os::raw::c_int,
    ///< required SPS height info
    pub iSpsHeightInPixel: ::std::os::raw::c_int,
    ///< input BS timestamp
    pub uiInBsTimeStamp: ::std::os::raw::c_ulonglong,
    ///< output BS timestamp
    pub uiOutBsTimeStamp: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_TagParserBsInfo() {
    assert_eq!(::std::mem::size_of::<TagParserBsInfo>() , 552usize);
    assert_eq!(::std::mem::align_of::<TagParserBsInfo>() , 8usize);
}
pub type SParserBsInfo = TagParserBsInfo;
pub type PParserBsInfo = *mut TagParserBsInfo;
/**
* @brief Structure for encoder statistics
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagVideoEncoderStatistics {
    ///< the width of encoded frame
    pub uiWidth: ::std::os::raw::c_uint,
    ///< the height of encoded frame
    pub uiHeight: ::std::os::raw::c_uint,
    ///< average_Encoding_Time
    pub fAverageFrameSpeedInMs: f32,
    ///< the average frame rate in, calculate since encoding starts, supposed that the input timestamp is in unit of ms
    pub fAverageFrameRate: f32,
    ///< the frame rate in, in the last second, supposed that the input timestamp is in unit of ms (? useful for checking BR, but is it easy to calculate?
    pub fLatestFrameRate: f32,
    ///< sendrate in Bits per second, calculated within the set time-window
    pub uiBitRate: ::std::os::raw::c_uint,
    ///< the average QP of last encoded frame
    pub uiAverageFrameQP: ::std::os::raw::c_uint,
    ///< number of frames
    pub uiInputFrameCount: ::std::os::raw::c_uint,
    ///< number of frames
    pub uiSkippedFrameCount: ::std::os::raw::c_uint,
    ///< uiResolutionChangeTimes
    pub uiResolutionChangeTimes: ::std::os::raw::c_uint,
    ///< number of IDR requests
    pub uiIDRReqNum: ::std::os::raw::c_uint,
    ///< number of actual IDRs sent
    pub uiIDRSentNum: ::std::os::raw::c_uint,
    ///< number of LTR sent/marked
    pub uiLTRSentNum: ::std::os::raw::c_uint,
    ///< Timestamp of updating the statistics
    pub iStatisticsTs: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_TagVideoEncoderStatistics() {
    assert_eq!(::std::mem::size_of::<TagVideoEncoderStatistics>() , 64usize);
    assert_eq!(::std::mem::align_of::<TagVideoEncoderStatistics>() , 8usize);
}
impl Clone for TagVideoEncoderStatistics {
    fn clone(&self) -> Self { *self }
}
pub type SEncoderStatistics = TagVideoEncoderStatistics;
/**
* @brief  Structure for decoder statistics
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagVideoDecoderStatistics {
    ///< the width of encode/decode frame
    pub uiWidth: ::std::os::raw::c_uint,
    ///< the height of encode/decode frame
    pub uiHeight: ::std::os::raw::c_uint,
    ///< average_Decoding_Time
    pub fAverageFrameSpeedInMs: f32,
    ///< actual average_Decoding_Time, including freezing pictures
    pub fActualAverageFrameSpeedInMs: f32,
    ///< number of frames
    pub uiDecodedFrameCount: ::std::os::raw::c_uint,
    ///< uiResolutionChangeTimes
    pub uiResolutionChangeTimes: ::std::os::raw::c_uint,
    ///< number of correct IDR received
    pub uiIDRCorrectNum: ::std::os::raw::c_uint,
    ///< when EC is on, the average ratio of total EC areas, can be an indicator of reconstruction quality
    pub uiAvgEcRatio: ::std::os::raw::c_uint,
    ///< when EC is on, the rough average ratio of propogate EC areas, can be an indicator of reconstruction quality
    pub uiAvgEcPropRatio: ::std::os::raw::c_uint,
    ///< number of actual unintegrity IDR or not received but eced
    pub uiEcIDRNum: ::std::os::raw::c_uint,
    ///<
    pub uiEcFrameNum: ::std::os::raw::c_uint,
    ///< number of whole lost IDR
    pub uiIDRLostNum: ::std::os::raw::c_uint,
    ///< number of freezing IDR with error (partly received), under resolution change
    pub uiFreezingIDRNum: ::std::os::raw::c_uint,
    ///< number of freezing non-IDR with error
    pub uiFreezingNonIDRNum: ::std::os::raw::c_uint,
    ///< average luma QP. default: -1, no correct frame outputted
    pub iAvgLumaQp: ::std::os::raw::c_int,
    ///< number of Sps Invalid report
    pub iSpsReportErrorNum: ::std::os::raw::c_int,
    ///< number of SubSps Invalid report
    pub iSubSpsReportErrorNum: ::std::os::raw::c_int,
    ///< number of Pps Invalid report
    pub iPpsReportErrorNum: ::std::os::raw::c_int,
    ///< number of Sps NoExist Nal
    pub iSpsNoExistNalNum: ::std::os::raw::c_int,
    ///< number of SubSps NoExist Nal
    pub iSubSpsNoExistNalNum: ::std::os::raw::c_int,
    ///< number of Pps NoExist Nal
    pub iPpsNoExistNalNum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TagVideoDecoderStatistics() {
    assert_eq!(::std::mem::size_of::<TagVideoDecoderStatistics>() , 84usize);
    assert_eq!(::std::mem::align_of::<TagVideoDecoderStatistics>() , 4usize);
}
impl Clone for TagVideoDecoderStatistics {
    fn clone(&self) -> Self { *self }
}
pub type SDecoderStatistics = TagVideoDecoderStatistics;
/**
* @brief Structure for sample aspect ratio (SAR) info in VUI
*/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TagVuiSarInfo {
    ///< SAR width
    pub uiSarWidth: ::std::os::raw::c_uint,
    ///< SAR height
    pub uiSarHeight: ::std::os::raw::c_uint,
    ///< SAR overscan flag
    pub bOverscanAppropriateFlag: bool,
}
#[test]
fn bindgen_test_layout_TagVuiSarInfo() {
    assert_eq!(::std::mem::size_of::<TagVuiSarInfo>() , 12usize);
    assert_eq!(::std::mem::align_of::<TagVuiSarInfo>() , 4usize);
}
impl Clone for TagVuiSarInfo {
    fn clone(&self) -> Self { *self }
}
pub type SVuiSarInfo = TagVuiSarInfo;
pub type PVuiSarInfo = *mut TagVuiSarInfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ISVCEncoderVtbl {
    pub Initialize: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ISVCEncoder,
                                                               pParam:
                                                                   *const SEncParamBase)
                                              -> ::std::os::raw::c_int>,
    pub InitializeExt: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ISVCEncoder,
                                                                  pParam:
                                                                      *const SEncParamExt)
                                                 -> ::std::os::raw::c_int>,
    pub GetDefaultParams: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ISVCEncoder,
                                                                     pParam:
                                                                         *mut SEncParamExt)
                                                    -> ::std::os::raw::c_int>,
    pub Uninitialize: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ISVCEncoder)
                                                -> ::std::os::raw::c_int>,
    pub EncodeFrame: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ISVCEncoder,
                                                                kpSrcPic:
                                                                    *const SSourcePicture,
                                                                pBsInfo:
                                                                    *mut SFrameBSInfo)
                                               -> ::std::os::raw::c_int>,
    pub EncodeParameterSets: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ISVCEncoder,
                                                                        pBsInfo:
                                                                            *mut SFrameBSInfo)
                                                       ->
                                                           ::std::os::raw::c_int>,
    pub ForceIntraFrame: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ISVCEncoder,
                                                                    bIDR:
                                                                        bool)
                                                   -> ::std::os::raw::c_int>,
    pub SetOption: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ISVCEncoder,
                                                              eOptionId:
                                                                  ENCODER_OPTION,
                                                              pOption:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_int>,
    pub GetOption: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ISVCEncoder,
                                                              eOptionId:
                                                                  ENCODER_OPTION,
                                                              pOption:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_ISVCEncoderVtbl() {
    assert_eq!(::std::mem::size_of::<ISVCEncoderVtbl>() , 72usize);
    assert_eq!(::std::mem::align_of::<ISVCEncoderVtbl>() , 8usize);
}
impl Clone for ISVCEncoderVtbl {
    fn clone(&self) -> Self { *self }
}
pub type ISVCEncoder = *const ISVCEncoderVtbl;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ISVCDecoderVtbl {
    pub Initialize: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ISVCDecoder,
                                                               pParam:
                                                                   *const SDecodingParam)
                                              -> ::std::os::raw::c_long>,
    pub Uninitialize: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ISVCDecoder)
                                                -> ::std::os::raw::c_long>,
    pub DecodeFrame: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ISVCDecoder,
                                                                pSrc:
                                                                    *const ::std::os::raw::c_uchar,
                                                                iSrcLen:
                                                                    ::std::os::raw::c_int,
                                                                ppDst:
                                                                    *mut *mut ::std::os::raw::c_uchar,
                                                                pStride:
                                                                    *mut ::std::os::raw::c_int,
                                                                iWidth:
                                                                    *mut ::std::os::raw::c_int,
                                                                iHeight:
                                                                    *mut ::std::os::raw::c_int)
                                               -> _bindgen_ty_7>,
    pub DecodeFrameNoDelay: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ISVCDecoder,
                                                                       pSrc:
                                                                           *const ::std::os::raw::c_uchar,
                                                                       iSrcLen:
                                                                           ::std::os::raw::c_int,
                                                                       ppDst:
                                                                           *mut *mut ::std::os::raw::c_uchar,
                                                                       pDstInfo:
                                                                           *mut SBufferInfo)
                                                      -> _bindgen_ty_7>,
    pub DecodeFrame2: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ISVCDecoder,
                                                                 pSrc:
                                                                     *const ::std::os::raw::c_uchar,
                                                                 iSrcLen:
                                                                     ::std::os::raw::c_int,
                                                                 ppDst:
                                                                     *mut *mut ::std::os::raw::c_uchar,
                                                                 pDstInfo:
                                                                     *mut SBufferInfo)
                                                -> _bindgen_ty_7>,
    pub DecodeParser: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ISVCDecoder,
                                                                 pSrc:
                                                                     *const ::std::os::raw::c_uchar,
                                                                 iSrcLen:
                                                                     ::std::os::raw::c_int,
                                                                 pDstInfo:
                                                                     *mut SParserBsInfo)
                                                -> _bindgen_ty_7>,
    pub DecodeFrameEx: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ISVCDecoder,
                                                                  pSrc:
                                                                      *const ::std::os::raw::c_uchar,
                                                                  iSrcLen:
                                                                      ::std::os::raw::c_int,
                                                                  pDst:
                                                                      *mut ::std::os::raw::c_uchar,
                                                                  iDstStride:
                                                                      ::std::os::raw::c_int,
                                                                  iDstLen:
                                                                      *mut ::std::os::raw::c_int,
                                                                  iWidth:
                                                                      *mut ::std::os::raw::c_int,
                                                                  iHeight:
                                                                      *mut ::std::os::raw::c_int,
                                                                  iColorFormat:
                                                                      *mut ::std::os::raw::c_int)
                                                 -> _bindgen_ty_7>,
    pub SetOption: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ISVCDecoder,
                                                              eOptionId:
                                                                  DECODER_OPTION,
                                                              pOption:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_long>,
    pub GetOption: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ISVCDecoder,
                                                              eOptionId:
                                                                  DECODER_OPTION,
                                                              pOption:
                                                                  *mut ::std::os::raw::c_void)
                                             -> ::std::os::raw::c_long>,
}
#[test]
fn bindgen_test_layout_ISVCDecoderVtbl() {
    assert_eq!(::std::mem::size_of::<ISVCDecoderVtbl>() , 72usize);
    assert_eq!(::std::mem::align_of::<ISVCDecoderVtbl>() , 8usize);
}
impl Clone for ISVCDecoderVtbl {
    fn clone(&self) -> Self { *self }
}
pub type ISVCDecoder = *const ISVCDecoderVtbl;
pub type WelsTraceCallback =
    ::std::option::Option<unsafe extern "C" fn(ctx:
                                                   *mut ::std::os::raw::c_void,
                                               level: ::std::os::raw::c_int,
                                               string:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    /** @brief   Create encoder
 *  @param   ppEncoder encoder
 *  @return  0 - success; otherwise - failed;
*/
    pub fn WelsCreateSVCEncoder(ppEncoder: *mut *mut ISVCEncoder)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** @brief   Destroy encoder
*   @param   pEncoder encoder
 *  @return  void
*/
    pub fn WelsDestroySVCEncoder(pEncoder: *mut ISVCEncoder);
}
extern "C" {
    /** @brief   Get the capability of decoder
 *  @param   pDecCapability  decoder capability
 *  @return  0 - success; otherwise - failed;
*/
    pub fn WelsGetDecoderCapability(pDecCapability: *mut SDecoderCapability)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /** @brief   Create decoder
 *  @param   ppDecoder decoder
 *  @return  0 - success; otherwise - failed;
*/
    pub fn WelsCreateDecoder(ppDecoder: *mut *mut ISVCDecoder)
     -> ::std::os::raw::c_long;
}
extern "C" {
    /** @brief   Destroy decoder
 *  @param   pDecoder  decoder
 *  @return  void
*/
    pub fn WelsDestroyDecoder(pDecoder: *mut ISVCDecoder);
}
extern "C" {
    /** @brief   Get codec version
 *           Note, old versions of Mingw (GCC < 4.7) are buggy and use an
 *           incorrect/different ABI for calling this function, making it
 *           incompatible with MSVC builds.
 *  @return  The linked codec version
*/
    pub fn WelsGetCodecVersion() -> OpenH264Version;
}
extern "C" {
    /** @brief   Get codec version
 *  @param   pVersion  struct to fill in with the version
*/
    pub fn WelsGetCodecVersionEx(pVersion: *mut OpenH264Version);
}
